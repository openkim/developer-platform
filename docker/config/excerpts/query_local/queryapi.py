#!/usr/bin/python3
r"""
The KIM Repository contains model drivers, models, test drivers, tests,
verification checks, and reference data, as well as results/errors generated by
running models against tests and verification checks.  All of these items are
inserted into a publicly accessible mongo database hosted at
[https://query.openkim.org](https://query.openkim.org).  Since querying mongo
directly can be tedious, a set of "simplified queries" for specific test
results have been introduced and are outlined below.

For each simplified query, the python function prototype is shown, followed by
a brief description and a link to the KIM Property Definition it corresponds
to.  Users interested in using these functions directly from python should
install the kim-query [kim-query](https://https://github.com/openkim/kim-query)
package.  They can also be accessed (1) within LAMMPS using the 'kim query'
command or (2) via web request using curl/wget/etc.  Examples of all three
usages are given for each function, as well as a listing of all input and
output parameters.

**NOTES:**
 - All input parameters are arrays enclosed in square brackets.  These arrays
   always contain either double-quoted strings, e.g. ["Al"], or numbers, e.g.
   [293.15].  Multiple entries should be separated by commas; generally, spaces
   following commas should be avoided.

 - The 'model' parameter indicates which KIM model is used to compute the
   result.  In order to retrieve the result for the latest version of a model,
   the 3-digit version extension at the end of the KIM ID should be omitted.
   For example, a value of ["EDIP_JustoBazantKaxiras_1998_Si__MO_958932894036"]
   will retrieve results computing the latest version of this model.  However,
   if a 3-digit version extension is given, it will be respected: only test
   results computed using that specific version of the model will be retrieved.
   Finally, the human-readable prefix in the model ID is discarded, so
   ["MO_958932894036"] will also query for the latest results of the
   aforementioned EDIP model.

 - The 'method' parameter indicates the test driver (algorithm) used to compute
   the results being retrieved.  As with models, it is generally desirable to
   omit a specific three-digit version extension, which causes the result
   computed using the latest version of the test driver to be retrieved.  The
   human-readable prefix of the test driver is also discarded, e.g.
   ["TD_475411767977"] will query for results computing a KIM test that uses
   the latest version of the LatticeConstantCubicEnergy__TD_475411767977 test
   driver.

   For many query functions, there are synonyms for specific KIM IDs to
   promote readability.  For example, for the `get_lattice_constant_cubic`
   query, "relaxation" is equivalent to test driver TD_475411767977.  Note
   that when using a synonym, a version is not provided, and so results
   returned are always for the latest version.  The available synonyms are
   listed in the method table next to their corresponding test driver KIM ID
   separated by a vertical bar (|).

Copyright (c) 2014-2022, Regents of the University of Minnesota. All rights
reserved.

This software may be distributed as-is, without modification.
"""

import re
import random
from json.decoder import JSONDecodeError

from bson.code import Code
from bson.json_util import dumps, loads

from ..kimunits import convert_units, convert_list
from . import helper_functions as helpers


def api_v0(db, data, origin=None):
    stuff = None

    rmap = data.get("map", None)
    rreduce = data.get("reduce", None)
    database = data.get("database", "data")
    query = data.get("query", None)
    fields = data.get("fields", None)
    sort = data.get("sort", None)
    distinct = data.get("distinct", None)
    skip = data.get("skip", None)
    limit = data.get("limit", None)
    project = data.get("project", None)
    flat = data.get("flat", None)
    history = data.get("history", None)
    count = data.get("count", None)

    try:
        try:
            database = loads(database)
        except ValueError:
            pass
        dbguy = db[database]
        query = query or "{}"

        # here, we make sure to only return latest usually
        if not history and database in ["obj", "data"]:
            basequery = {"latest": True}
            basequery.update(loads(query))
            query = dumps(basequery)

        # update the fields to not include _id by default
        basefields = {"_id": 0}
        if fields:
            basefields.update(loads(fields))
        fields = dumps(basefields)

        if rmap and rreduce:
            tcollname = "tmp_%010d" % random.randint(0, 1e10)
            try:
                rmap, rreduce = loads(rmap), loads(rreduce)
            except JSONDecodeError:
                pass
            cursor = dbguy.map_reduce(
                Code(rmap), Code(rreduce), tcollname, query=loads(query)
            ).find()
        else:
            if fields:
                cursor = dbguy.find(loads(query), loads(fields))
            else:
                cursor = dbguy.find(loads(query))
        if sort:
            cursor = cursor.sort(loads(sort))
        if skip:
            cursor = cursor.skip(loads(skip))
        if limit:
            cursor = cursor.limit(loads(limit))
        if distinct:
            cursor = cursor.distinct(loads(distinct))
        if cursor:
            stuff = cursor
        if project or flat:
            stuff = helpers.flatten(stuff)
            if project:
                stuff = helpers.doproject(stuff, loads(project))
        if count:
            stuff = cursor.count(with_limit_and_skip=True)

    except Exception as e:
        return {"error": str(e)}
    return stuff


def get_lattice_constant_cubic(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve the equilibrium lattice constant of the conventional unit cell
    of a cubic crystal comprised of one or more species at a given temperature
    and hydrostatic pressure

    KIM Property Definition: [structure-cubic-crystal-npt](https://openkim.org/properties/show/2014-04-15/staff@noreply.openkim.org/structure-cubic-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query a0 get_lattice_constant_cubic crystal=["fcc"] species=["Al"] units=["angstrom"]
      ```

    python:

      ```
      from kim_python_utils.query import get_lattice_constant_cubic
      get_lattice_constant_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], ["angstrom"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'crystal=["fcc"]'               \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["angstrom"]'            \
           https://query.openkim.org/api/get_lattice_constant_cubic
      ```


    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of length supported by [GNU units](https://www.gnu.org/software/units/)
        in which the lattice constant will be returned, e.g. "angstrom".

    temperature : array containing one float, optional
        The temperature at which the equilibrium lattice geometry is computed.
        This value should be given in the units specified by the
        'temperature_units' argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the equilibrium lattice geometry is
        computed.  This value should be given in the units specified by the
        'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the lattice constant.  Currently allowed
        values are:

      |-----------------------------------+------------------------------------------------------|
      | Allowed values                    | Description                                          |
      |-----------------------------------|------------------------------------------------------|
      | "TD_475411767977" \| "relaxation" | Nelder-Mead downhill simplex minimization. (default) |
      |-----------------------------------+------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [a] : array containing one float
        The lattice constant of the conventional unit cell of the cubic crystal
        in the requested units.

    """
    method_synonyms = {"relaxation": "TD_475411767977"}

    allowed_values = {
        "method": [["TD_475411767977"]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "structure-cubic-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["a"] = 1
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_lattice_constant_cubic")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            a = helpers.extract_key_from_result(final_TestResults[0], "a", units)
            return [a]


def get_lattice_constant_hexagonal(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve equilibrium lattice constants of the conventional unit cell of
    a hexagonal crystal comprised of one or more species at a given temperature
    and hydrostatic pressure

    KIM Property Definition: [structure-hexagonal-crystal-npt](https://openkim.org/properties/show/2014-04-15/staff@noreply.openkim.org/structure-hexagonal-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_Mendelev_2007_Zr__MO_848899341753_000 metal
      kim_query latconst split get_lattice_constant_hexagonal crystal=["hcp"] species=["Zr"] units=["angstrom"]
      ```

    python:

      ```
      from kim_python_utils.query import get_lattice_constant_hexagonal
      get_lattice_constant_hexagonal(["MO_848899341753_000"], ["hcp"], ["Zr"], ["angstrom"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_848899341753_000"]' \
           --data-urlencode 'crystal=["hcp"]'               \
           --data-urlencode 'species=["Zr"]'                \
           --data-urlencode 'units=["angstrom"]'            \
           https://query.openkim.org/api/get_lattice_constant_hexagonal
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the hexagonal crystal.  Currently allowed values are
        "graphite", "hcp", and "sh".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of length supported by [GNU units](https://www.gnu.org/software/units/)
        in which the lattice constants will be returned, e.g. "angstrom".

    temperature : array containing one float, optional
        The temperature at which the equilibrium lattice geometry is computed.
        This value should be given in the units specified by the
        'temperature_units' argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the equilibrium lattice geometry is
        computed.  This value should be given in the units specified by the
        'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the lattice constants.  Currently allowed
        values are:

      |-----------------------------------+------------------------------------------------------|
      | Allowed values                    | Description                                          |
      |-----------------------------------|------------------------------------------------------|
      | "TD_942334626465" \| "relaxation" | Nelder-Mead downhill simplex minimization. (default) |
      |-----------------------------------+------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [a, c] : array containing two floats
        The lattice constants of the conventional unit cell of the hexagonal
        crystal in the requested units.

    """
    method_synonyms = {"relaxation": "TD_942334626465"}

    allowed_values = {
        "method": [["TD_942334626465"]],
        "crystal": [["graphite"], ["hcp"], ["sh"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "structure-hexagonal-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["a"] = 1
    query["fields"]["c"] = 1
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_lattice_constant_hexagonal")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            a = helpers.extract_key_from_result(final_TestResults[0], "a", units)
            c = helpers.extract_key_from_result(final_TestResults[0], "c", units)
            return [a, c]


def get_lattice_constant_2Dhexagonal(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve equilibrium lattice constant of the conventional unit cell of
    a 2D hexagonal crystal comprised of one or more species at a given
    temperature and hydrostatic pressure

    KIM Property Definition: [structure-2d-hexagonal-crystal-npt](https://openkim.org/properties/show/2015-05-26/staff@noreply.openkim.org/structure-2d-hexagonal-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init Tersoff_LAMMPS_Tersoff_1988_C__MO_579868029681_002 metal
      kim_query a0 get_lattice_constant_2Dhexagonal crystal=["graphene-like"] species=["C"] units=["angstrom"]
      ```

    python:

      ```
      from kim_python_utils.query import get_lattice_constant_2Dhexagonal
      get_lattice_constant_2Dhexagonal(["MO_579868029681_002"], ["graphene-like"], ["C"], ["angstrom"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_579868029681_002"]' \
           --data-urlencode 'crystal=["graphene-like"]'     \
           --data-urlencode 'species=["C"]'                 \
           --data-urlencode 'units=["angstrom"]'            \
           https://query.openkim.org/api/get_lattice_constant_2Dhexagonal
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the 2D hexagonal crystal.  Currently, a single value
        is allowed:  "graphene-like".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the 2D
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of length supported by [GNU units](https://www.gnu.org/software/units/)
        in which the lattice constant will be returned, e.g. "angstrom".

    temperature : array containing one float, optional
        The temperature at which the equilibrium lattice geometry is computed.
        This value should be given in the units specified by the
        'temperature_units' argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the equilibrium lattice geometry is
        computed.  This value should be given in the units specified by the
        'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the lattice constant.  Currently allowed
        values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_034540307932" \| "relaxation" | Polak-Ribiere conjugate gradient minimization. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [a] : array containing one float
        The lattice constant of the conventional unit cell of the 2D hexagonal
        crystal in the requested units.

    """
    method_synonyms = {"relaxation": "TD_034540307932"}

    allowed_values = {"method": [["TD_034540307932"]], "crystal": [["graphene-like"]]}

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "structure-2d-hexagonal-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["a"] = 1
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-in-plane-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_lattice_constant_2Dhexagonal")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
            stress_name="cauchy-in-plane-stress",
        )

        if len(final_TestResults) == 0:
            return []
        else:
            a = helpers.extract_key_from_result(final_TestResults[0], "a", units)
            return [a]


def get_cohesive_energy_cubic(
    db, model, crystal, species, units, method=["relaxation"]
):
    r"""Retrieve cohesive energy of a cubic crystal comprised of one or more
    species at zero temperature and pressure

    KIM Property Definition: [cohesive-potential-energy-cubic-crystal](https://openkim.org/properties/show/2014-04-15/staff@noreply.openkim.org/cohesive-potential-energy-cubic-crystal)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Ec get_cohesive_energy_cubic crystal=["fcc"] species=["Al"] units=["eV"]
      ```

    python:

      ```
      from kim_python_utils.query import get_cohesive_energy_cubic
      get_cohesive_energy_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], ["eV"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'crystal=["fcc"]'               \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV"]'                  \
           https://query.openkim.org/api/get_cohesive_energy_cubic
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy supported by [GNU units](https://www.gnu.org/software/units/)
        in which the cohesive energy will be returned, e.g. "eV".

    method : array containing one double-quoted string, optional
        The algorithm used to compute the cohesive energy.  Currently allowed
        values are:

      |-----------------------------------+------------------------------------------------------|
      | Allowed values                    | Description                                          |
      |-----------------------------------|------------------------------------------------------|
      | "TD_475411767977" \| "relaxation" | Nelder-Mead downhill simplex minimization. (default) |
      |-----------------------------------+------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [cohesive_energy] : array containing one float
        The cohesive energy in the requested units.  This is the IUPAC definition,
        i.e. a stable crystal will have a *positive* cohesive energy.

    """
    method_synonyms = {"relaxation": "TD_475411767977"}

    allowed_values = {
        "method": [["TD_475411767977"]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "cohesive-potential-energy-cubic-crystal"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["cohesive-potential-energy"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_cohesive_energy_cubic")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        cohesive_energy = helpers.extract_key_from_result(
            results_from_query[0], "cohesive-potential-energy", units
        )
        return [cohesive_energy]


def get_cohesive_energy_hexagonal(
    db, model, crystal, species, units, method=["relaxation"]
):
    r"""Retrieve cohesive energy of a hexagonal crystal comprised of one or
    more species at zero temperature and pressure

    KIM Property Definition: [cohesive-potential-energy-hexagonal-crystal](https://openkim.org/properties/show/2014-04-15/staff@noreply.openkim.org/cohesive-potential-energy-hexagonal-crystal)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_Mendelev_2007_Zr__MO_848899341753_000 metal
      kim_query Ec get_cohesive_energy_hexagonal crystal=["hcp"] species=["Zr"] units=["eV"]
      ```

    python:

      ```
      from kim_python_utils.query import get_cohesive_energy_hexagonal
      get_cohesive_energy_hexagonal(["MO_848899341753_000"], ["hcp"], ["Zr"], ["eV"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_848899341753_000"]' \
           --data-urlencode 'crystal=["hcp"]'               \
           --data-urlencode 'species=["Zr"]'                \
           --data-urlencode 'units=["eV"]'                  \
           https://query.openkim.org/api/get_cohesive_energy_hexagonal
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the hexagonal crystal.  Currently allowed values are
        "graphite", "hcp", and "sh".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy supported by [GNU units](https://www.gnu.org/software/units/)
        in which the cohesive energy will be returned, e.g. "eV".

    method : array containing one double-quoted string, optional
        The algorithm used to compute the cohesive energy.  Currently allowed
        values are:

      |-----------------------------------+------------------------------------------------------|
      | Allowed values                    | Description                                          |
      |-----------------------------------|------------------------------------------------------|
      | "TD_942334626465" \| "relaxation" | Nelder-Mead downhill simplex minimization. (default) |
      |-----------------------------------+------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [cohesive_energy] : array containing one float
        The cohesive energy in the requested units.  This is the IUPAC definition,
        i.e. a stable crystal will have a *positive* cohesive energy.

    """
    # NOTE: This currently won't ever return any results because the current version of
    # the LatticeConstantHexagonal driver only reports
    # 'cohesive-free-energy-hexagonal-crystal' and 'structure-hexagonal-crystal-npt'
    method_synonyms = {"relaxation": "TD_942334626465"}

    allowed_values = {
        "method": [["TD_942334626465"]],
        "crystal": [["graphite"], ["hcp"], ["sh"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "cohesive-potential-energy-hexagonal-crystal"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["cohesive-potential-energy"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_cohesive_energy_hexagonal")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        cohesive_energy = helpers.extract_key_from_result(
            results_from_query[0], "cohesive-potential-energy", units
        )
        return [cohesive_energy]


def get_cohesive_energy_2Dhexagonal(
    db, model, crystal, species, units, method=["relaxation"]
):
    r"""Retrieve cohesive energy of a 2D hexagonal crystal comprised of one or
    more species at zero temperature and pressure

    KIM Property Definition: [cohesive-potential-energy-2d-hexagonal-crystal](https://openkim.org/properties/show/2015-05-26/staff@noreply.openkim.org/cohesive-potential-energy-2d-hexagonal-crystal)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init Tersoff_LAMMPS_Tersoff_1988_C__MO_579868029681_002 metal
      kim_query Ec get_cohesive_energy_2Dhexagonal crystal=["graphene-like"] species=["C"] units=["eV"]
      ```

    python:

      ```
      from kim_python_utils.query import get_cohesive_energy_2Dhexagonal
      get_cohesive_energy_2Dhexagonal(["MO_579868029681_002"], ["graphene-like"], ["C"], ["eV"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_579868029681_002"]' \
           --data-urlencode 'crystal=["graphene-like"]'     \
           --data-urlencode 'species=["C"]'                 \
           --data-urlencode 'units=["eV"]'                  \
           https://query.openkim.org/api/get_cohesive_energy_2Dhexagonal
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the hexagonal crystal.  Currently, only a single
        value is allowed:  "graphene-like".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy supported by [GNU units](https://www.gnu.org/software/units/)
        in which the cohesive energy will be returned, e.g. "eV".

    method : array containing one double-quoted string, optional
        The algorithm used to compute the cohesive energy.  Currently allowed
        values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_034540307932" \| "relaxation" | Polak-Ribiere conjugate gradient minimization. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [cohesive_energy] : array containing one float
        The cohesive energy in the requested units.  This is the IUPAC definition,
        i.e. a stable crystal will have a *positive* cohesive energy.

    """
    method_synonyms = {"relaxation": "TD_034540307932"}

    allowed_values = {"method": [["TD_034540307932"]], "crystal": [["graphene-like"]]}

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "cohesive-potential-energy-2d-hexagonal-crystal"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["cohesive-potential-energy"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_cohesive_energy_2dhexagonal")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        cohesive_energy = helpers.extract_key_from_result(
            results_from_query[0], "cohesive-potential-energy", units
        )
        return [cohesive_energy]


def get_elastic_constants_isothermal_cubic(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["finite-difference"],
):
    r"""Retrieve isothermal elastic constants of a cubic crystal comprised of
    one or more species at a given temperature and hydrostatic pressure

    KIM Property Definition: [elastic-constants-isothermal-cubic-crystal-npt](https://openkim.org/properties/show/2014-05-21/staff@noreply.openkim.org/elastic-constants-isothermal-cubic-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query elastconst split get_elastic_constants_isothermal_cubic crystal=["fcc"] species=["Al"] units=["GPa"]
      ```

    python:

      ```
      from kim_python_utils.query import get_elastic_constants_isothermal_cubic
      get_elastic_constants_isothermal_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], ["GPa"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'crystal=["fcc"]'               \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["GPa"]'                 \
           https://query.openkim.org/api/get_elastic_constants_isothermal_cubic
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the elastic constants will be returned, e.g. "GPa".

    temperature : array containing one float, optional
        The temperature at which the equilibrium elastic constants are
        computed.  This value should be given in the units specified by the
        'temperature_units' argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the elastic constants are computed.
        This value should be given in the units specified by the
        'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple results are found which match the specified
        pressure within this tolerance, an error is returned.  (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the elastic constants.  Currently allowed
        values are:

      |------------------------------------------+-----------------------------------------------------------------------------------|
      | Allowed values                           | Description                                                                       |
      |------------------------------------------|-----------------------------------------------------------------------------------|
      | "TD_011862047401" \| "finite-difference" | Second-order central finite differences and Richardson extrapolation used to approximate the Hessian of the energy. (default) |
      |------------------------------------------+-----------------------------------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [c11, c12, c44] : array containing three floats
        The isothermal cubic elastic constants in the requested units.

    """
    method_synonyms = {"finite-difference": "TD_011862047401"}

    allowed_values = {
        "method": [["TD_011862047401"]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "elastic-constants-isothermal-cubic-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["c11"] = (1,)
    query["fields"]["c12"] = (1,)
    query["fields"]["c44"] = (1,)
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_elastic_constants_isothermal_cubic"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            c11 = helpers.extract_key_from_result(final_TestResults[0], "c11", units)
            c12 = helpers.extract_key_from_result(final_TestResults[0], "c12", units)
            c44 = helpers.extract_key_from_result(final_TestResults[0], "c44", units)
            return [c11, c12, c44]


def get_bulk_modulus_isothermal_cubic(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["finite-difference"],
):
    r"""Retrieve isothermal bulk modulus of a cubic crystal comprised of one or
    more species at a given temperature and hydrostatic pressure

    KIM Property Definition: [bulk-modulus-isothermal-cubic-crystal-npt](https://openkim.org/properties/show/2014-04-15/staff@noreply.openkim.org/bulk-modulus-isothermal-cubic-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query B get_bulk_modulus_isothermal_cubic crystal=["fcc"] species=["Al"] units=["GPa"]
      ```

    python:

      ```
      from kim_python_utils.query import get_bulk_modulus_isothermal_cubic
      get_bulk_modulus_isothermal_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], ["GPa"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'crystal=["fcc"]'               \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["GPa"]'                 \
           https://query.openkim.org/api/get_bulk_modulus_isothermal_cubic
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the bulk modulus will be returned, e.g. "GPa".

    temperature : array containing one float, optional
        The temperature at which the bulk modulus is computed.  This value
        should be given in the units specified by the 'temperature_units'
        argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the bulk modulus is computed.  This value should
        be given in the units specified by the 'pressure_units' argument.
        (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the isothermal bulk modulus.  Currently
        allowed values are:

      |------------------------------------------+-----------------------------------------------------------------------------------|
      | Allowed values                           | Description                                                                       |
      |------------------------------------------|-----------------------------------------------------------------------------------|
      | "TD_011862047401" \| "finite-difference" | Second-order central finite differences and Richardson extrapolation used to approximate the Hessian of the energy. (default) |
      |------------------------------------------+-----------------------------------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [B] : array containing one float
        The isothermal bulk modulus in the requested units.

    """
    method_synonyms = {"finite-difference": "TD_011862047401"}

    allowed_values = {
        "method": [["TD_011862047401"]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "bulk-modulus-isothermal-cubic-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["isothermal-bulk-modulus"] = (1,)
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_bulk_modulus_isothermal_cubic")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            B = helpers.extract_key_from_result(
                final_TestResults[0], "isothermal-bulk-modulus", units
            )
            return [B]


def get_bulk_modulus_isothermal_hexagonal(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["finite-difference"],
):
    r"""Retrieve isothermal bulk modulus of a hexagonal crystal comprised of
    one or more species at zero temperature and pressure

    KIM Property Definition: [bulk-modulus-isothermal-hexagonal-crystal-npt](https://openkim.org/properties/show/2014-04-15/staff@noreply.openkim.org/bulk-modulus-isothermal-hexagonal-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_Mendelev_2007_Zr__MO_848899341753_000 metal
      kim_query B get_bulk_modulus_isothermal_hexagonal crystal=["hcp"] species=["Zr"] units=["GPa"]
      ```

    python:

      ```
      from kim_python_utils.query import get_bulk_modulus_isothermal_hexagonal
      get_bulk_modulus_isothermal_hexagonal(["MO_848899341753_000"], ["hcp"], ["Zr"], ["GPa"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_848899341753_000"]' \
           --data-urlencode 'crystal=["hcp"]'               \
           --data-urlencode 'species=["Zr"]'                \
           --data-urlencode 'units=["GPa"]'                 \
           https://query.openkim.org/api/get_bulk_modulus_isothermal_hexagonal
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the hexagonal crystal.  Currently allowed values are
        "graphite", "hcp", and "sh".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the bulk modulus will be returned, e.g. "GPa".

    temperature : array containing one float, optional
        The temperature at which the bulk modulus is computed.  This value
        should be given in the units specified by the 'temperature_units'
        argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the bulk modulus is computed.  This value should
        be given in the units specified by the 'pressure_units' argument.
        (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match
        the pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the isothermal bulk modulus.  Currently
        allowed values are:

      |------------------------------------------+-----------------------------------------------------------------------------------|
      | Allowed values                           | Description                                                                       |
      |------------------------------------------|-----------------------------------------------------------------------------------|
      | "TD_612503193866" \| "finite-difference" | Second-order central finite differences and Richardson extrapolation used to approximate the Hessian of the energy. (default) |
      |------------------------------------------+-----------------------------------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [B] : array containing one float
        The isothermal bulk modulus in the requested units.

    """
    method_synonyms = {"finite-difference": "TD_612503193866"}

    allowed_values = {
        "method": [["TD_612503193866"]],
        "crystal": [["graphite"], ["hcp"], ["sh"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "bulk-modulus-isothermal-hexagonal-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["isothermal-bulk-modulus"] = (1,)
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_bulk_modulus_isothermal_hexagonal"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            B = helpers.extract_key_from_result(
                final_TestResults[0], "isothermal-bulk-modulus", units
            )
            return [B]


def get_linear_thermal_expansion_coefficient_cubic(
    db,
    model,
    crystal,
    species,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["md-volume-expansion"],
):
    r"""Retrieve linear coefficient of thermal expansion of a cubic crystal
    comprised of one or more species at a given temperature and hydrostatic pressure,
    calculated according to (change-in-length)/(original-length)/(change-in-temperature)

    KIM Property Definition: [linear-thermal-expansion-coefficient-cubic-crystal-npt](https://openkim.org/properties/show/2015-07-30/staff@noreply.openkim.org/linear-thermal-expansion-coefficient-cubic-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query alpha get_linear_thermal_expansion_coefficient_cubic crystal=["fcc"] species=["Al"] units=["1/K"] temperature=[293.15] temperature_units=["K"]
      ```

    python:

      ```
      from kim_python_utils.query import get_linear_thermal_expansion_coefficient_cubic
      get_linear_thermal_expansion_coefficient_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], ["1/K"], [293.15])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'crystal=["fcc"]'               \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["1/K"]'                 \
           --data-urlencode 'temperature=[293.15]'          \
           https://query.openkim.org/api/get_linear_thermal_expansion_coefficient_cubic
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of 1/temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the bulk modulus will be returned, e.g. "1/K".

    temperature : array containing one float, optional
        The temperature at which the linear thermal expansion coefficient is to
        be computed.  This value should be given in the units specified
        by the 'temperature_units' argument.  (Default: 293.15)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the linear thermal expansion coefficient is to
        be computed.  This value should be given in the units specified
        by the 'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to compute the linear thermal expansion coefficient.
        Currently allowed values are:

      |--------------------------------------------+-----------------------------------------------------------------------------------|
      | Allowed values                             | Description                                                                       |
      |--------------------------------------------|-----------------------------------------------------------------------------------|
      | "TD_522633393614" \| "md-volume-expansion" | Time integration performed under npt ensemble using a Nose-Hoover thermostat and barostate at a range of temperatures while allowing the system volume to change, recording the average volume once the temperature and pressure have converged. (default)
      |--------------------------------------------+-----------------------------------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [alpha] : array containing one float
        The linear thermal expansion coefficient in the requested units.

    """
    method_synonyms = {"md-volume-expansion": "TD_522633393614"}

    allowed_values = {
        "method": [["TD_522633393614"]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "temperature": temperature,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "linear-thermal-expansion-coefficient-cubic-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["linear-thermal-expansion-coefficient"] = 1
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_linear_thermal_expansion_coefficient_cubic"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            alpha = helpers.extract_key_from_result(
                final_TestResults[0], "linear-thermal-expansion-coefficient", units
            )
            return [alpha]


def get_intrinsic_stacking_fault_relaxed_energy_fcc(
    db,
    model,
    species,
    units,
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve relaxed intrinsic stacking fault (ISF) energy for a
    face-centered monoatomic cubic crystal at zero temperature and a specified
    pressure.  The ISF corresponds to a fault of the form ABC|BCA.  Relaxation
    of the atomic coordinates is performed in the direction perpendicular to
    the fault plane

    KIM Property Definition: [intrinsic-stacking-fault-relaxed-energy-fcc-crystal-npt](https://openkim.org/properties/show/2015-05-26/staff@noreply.openkim.org/intrinsic-stacking-fault-relaxed-energy-fcc-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Estack_intr get_intrinsic_stacking_fault_relaxed_energy_fcc species=["Al"] units=["eV/angstrom^2"]
      ```

    python:

      ```
      from kim_python_utils.query import get_intrinsic_stacking_fault_relaxed_energy_fcc
      get_intrinsic_stacking_fault_relaxed_energy_fcc(["MO_123629422045_005"], ["Al"], ["eV/angstrom^2"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV/angstrom^2"]'       \
           https://query.openkim.org/api/get_intrinsic_stacking_fault_relaxed_energy_fcc
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    species : array containing one string
        The standard chemical symbol of the single atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy per unit area supported by [GNU units](https://www.gnu.org/software/units/)
        in which the relaxed intrinsic stacking fault energy will be returned,
        e.g. "eV/angstrom^2".

    pressure : array containing one float, optional
        The pressure at which the relaxed stacking fault energy is
        computed.  This value should be given in the units specified by the
        'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to relax the atomic positions in order to compute
        the relaxed intrinsic stacking fault energy for a given lattice
        constant.  Currently allowed values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_228501831190" \| "relaxation" | Polak-Ribiere conjugate gradient minimization. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [intrinsic_stacking_fault_energy] : array containing one float
        The relaxed intrinsic stacking fault energy of the monoatomic FCC
        crystal in the requested units.

    """
    method_synonyms = {"relaxation": "TD_228501831190"}

    allowed_values = {"method": [["TD_228501831190"]]}

    inputs = {
        "model": model,
        "species": species,
        "units": units,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    units = units[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "intrinsic-stacking-fault-relaxed-energy-fcc-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["intrinsic-stacking-fault-energy"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_intrinsic_stacking_fault_relaxed_energy_fcc"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_pressure(
            results_from_query, pressure, pressure_units, pressure_tol
        )

        if len(final_TestResults) == 0:
            return []
        else:
            intrinsic_stacking_fault_energy = helpers.extract_key_from_result(
                final_TestResults[0], "intrinsic-stacking-fault-energy", units
            )
            return [intrinsic_stacking_fault_energy]


def get_extrinsic_stacking_fault_relaxed_energy_fcc(
    db,
    model,
    species,
    units,
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve relaxed extrinsic stacking fault (ESF) energy for a
    face-centered monoatomic cubic crystal at zero temperature and a specified
    pressure.  The ESF corresponds to an ABC|BA|BC stacking, which can also be
    understood as a two-layer twin nucleus.  Relaxation of the atomic
    coordinates is performed in the direction perpendicular to the fault plane

    KIM Property Definition: [extrinsic-stacking-fault-relaxed-energy-fcc-crystal-npt](https://openkim.org/properties/show/2015-05-26/staff@noreply.openkim.org/extrinsic-stacking-fault-relaxed-energy-fcc-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Estack_extr get_extrinsic_stacking_fault_relaxed_energy_fcc species=["Al"] units=["eV/angstrom^2"]
      ```

    python:

      ```
      from kim_python_utils.query import get_extrinsic_stacking_fault_relaxed_energy_fcc
      get_extrinsic_stacking_fault_relaxed_energy_fcc(["MO_123629422045_005"], ["Al"], ["eV/angstrom^2"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV/angstrom^2"]'       \
           https://query.openkim.org/api/get_extrinsic_stacking_fault_relaxed_energy_fcc
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    species : array containing one string
        The standard chemical symbol of the single atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy per unit area supported by [GNU units](https://www.gnu.org/software/units/)
        in which the relaxed intrinsic stacking fault energy will be returned,
        e.g. "eV/angstrom^2".

    pressure : array containing one float, optional
        The pressure at which the relaxed stacking fault energy is
        computed.  This value should be given in the units specified by the
        'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to relax the atomic positions in order to compute
        the relaxed extrinsic stacking fault energy for a given lattice
        constant.  Currently allowed values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_228501831190" \| "relaxation" | Polak-Ribiere conjugate gradient minimization. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [extrinsic_stacking_fault_energy] : array containing one float
        The relaxed extrinsic stacking fault energy of the monoatomic FCC
        crystal in the requested units.

    """
    method_synonyms = {"relaxation": "TD_228501831190"}

    allowed_values = {"method": [["TD_228501831190"]]}

    inputs = {
        "model": model,
        "species": species,
        "units": units,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    units = units[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "extrinsic-stacking-fault-relaxed-energy-fcc-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["extrinsic-stacking-fault-energy"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_extrinsic_stacking_fault_relaxed_energy_fcc"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_pressure(
            results_from_query, pressure, pressure_units, pressure_tol
        )

        if len(final_TestResults) == 0:
            return []
        else:
            extrinsic_stacking_fault_energy = helpers.extract_key_from_result(
                final_TestResults[0], "extrinsic-stacking-fault-energy", units
            )
            return [extrinsic_stacking_fault_energy]


def get_unstable_stacking_fault_relaxed_energy_fcc(
    db,
    model,
    species,
    units,
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve the relaxed unstable stacking fault (USF) energy of a
    face-centered monoatomic cubic crystal at zero temperature and a specified
    pressure.  The USE corresponds to the energy barrier for rigidly slipping
    one-half of an infinite crystal relative to the other along a <112>
    direction (fcc partial dislocation direction).  Relaxation of the atomic
    positions is performed perpendicular to the fault plane.

    KIM Property Definition: [unstable-stacking-fault-relaxed-energy-fcc-crystal-npt](https://openkim.org/properties/show/2015-05-26/staff@noreply.openkim.org/unstable-stacking-fault-relaxed-energy-fcc-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Estack_unstable get_unstable_stacking_fault_relaxed_energy_fcc species=["Al"] units=["eV/angstrom^2"]
      ```

    python:

      ```
      from kim_python_utils.query import get_unstable_stacking_fault_relaxed_energy_fcc
      get_unstable_stacking_fault_relaxed_energy_fcc(["MO_123629422045_005"], ["Al"], ["eV/angstrom^2"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV/angstrom^2"]'       \
           https://query.openkim.org/api/get_unstable_stacking_fault_relaxed_energy_fcc
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    species : array containing one string
        The standard chemical symbol of the single atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy per unit area supported by [GNU units](https://www.gnu.org/software/units/)
        in which the relaxed intrinsic stacking fault energy will be returned,
        e.g. "eV/angstrom^2".

    pressure : array containing one float, optional
        The pressure at which the relaxed unstable stacking fault energy is to
        be computed.  This value should be given in the units specified
        by the 'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to relax the atomic positions in order to compute
        the unstable stacking fault energy for a given lattice constant.
        Currently allowed values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_228501831190" \| "relaxation" | Polak-Ribiere conjugate gradient minimization. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [unstable_stacking_fault_energy] : array containing one float
        The relaxed unstable stacking fault energy of the monoatomic FCC
        crystal in the requested units.

    """
    method_synonyms = {"relaxation": "TD_228501831190"}

    allowed_values = {"method": [["TD_228501831190"]]}

    inputs = {
        "model": model,
        "species": species,
        "units": units,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    units = units[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "unstable-stacking-fault-relaxed-energy-fcc-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["unstable-stacking-energy"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_unstable_stacking_fault_relaxed_energy_fcc"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_pressure(
            results_from_query, pressure, pressure_units, pressure_tol
        )

        if len(final_TestResults) == 0:
            return []
        else:
            unstable_stacking_fault_energy = helpers.extract_key_from_result(
                final_TestResults[0], "unstable-stacking-energy", units
            )
            return [unstable_stacking_fault_energy]


def get_unstable_twinning_fault_relaxed_energy_fcc(
    db,
    model,
    species,
    units,
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["relaxation"],
):
    r"""Retrieve the relaxed unstable twinning fault energy (UTFE) of a
    face-centered monoatomic cubic crystal at zero temperature and a specified
    pressure.  The UTFE corresponds to the energy barrier for rigidly slipping
    one part of an infinite crystal on a {111} plane adjacent to a preexisting
    intrinsic stacking fault relative to the other part along a <112> direction
    (fcc partial dislocation direction).  Relaxation of the atomic coordinates
    is performed perpendicular to the fault plane.

    KIM Property Definition: [unstable-twinning-fault-relaxed-energy-fcc-crystal-npt](https://openkim.org/properties/show/2015-05-26/staff@noreply.openkim.org/unstable-twinning-fault-relaxed-energy-fcc-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Etwin_unstable get_unstable_twinning_fault_relaxed_energy_fcc species=["Al"] units=["eV/angstrom^2"]
      ```

    python:

      ```
      from kim_python_utils.query import get_unstable_twinning_fault_relaxed_energy_fcc
      get_unstable_twinning_fault_relaxed_energy_fcc(["MO_123629422045_005"], ["Al"], ["eV/angstrom^2"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV/angstrom^2"]'       \
           https://query.openkim.org/api/get_unstable_twinning_fault_relaxed_energy_fcc
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    species : array containing one string
        The standard chemical symbol of the single atomic species comprising the
        crystal, e.g. "Al".

    units : array containing one double-quoted string
        A physical unit of energy per unit area supported by [GNU units](https://www.gnu.org/software/units/)
        in which the relaxed intrinsic stacking fault energy will be returned,
        e.g. "eV/angstrom^2".

    pressure : array containing one float, optional
        The pressure at which the relaxed unstable twinning fault energy is to
        be computed.  This value should be given in the units specified
        by the 'pressure_units' argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to relax the atomic positions in order to compute
        the unstable twinning fault energy for a given lattice constant.
        Currently allowed values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_228501831190" \| "relaxation" | Polak-Ribiere conjugate gradient minimization. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [unstable_twinning_fault_energy] : array containing one float
        The relaxed unstable twinning fault energy of the monoatomic FCC
        crystal in the requested units.

    """
    method_synonyms = {"relaxation": "TD_228501831190"}

    allowed_values = {"method": [["TD_228501831190"]]}

    inputs = {
        "model": model,
        "species": species,
        "units": units,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    units = units[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "unstable-twinning-fault-relaxed-energy-fcc-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["unstable-twinning-energy"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(
        db, query, origin="get_unstable_twinning_fault_relaxed_energy_fcc"
    )

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_pressure(
            results_from_query, pressure, pressure_units, pressure_tol
        )

        if len(final_TestResults) == 0:
            return []
        else:
            unstable_twinning_fault_energy = helpers.extract_key_from_result(
                final_TestResults[0], "unstable-twinning-energy", units
            )
            return [unstable_twinning_fault_energy]


def get_surface_energy_ideal_cubic(
    db, model, crystal, species, miller, units, method=["TD_955413365818"]
):
    r"""Retrieve ideal surface energy of a high-symmetry surface in a cubic
    crystal comprised of one or more species at zero temperature and pressure,
    as computed by the latest current version of the
    SurfaceEnergyCubicCrystalBrokenBondFit Test Driver (TD_955413365818).

    KIM Property Definition: [surface-energy-ideal-cubic-crystal](https://openkim.org/properties/show/2014-05-21/staff@noreply.openkim.org/surface-energy-ideal-cubic-crystal)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Eideal get_surface_energy_ideal_cubic crystal=["fcc"] miller=[1,0,0] species=["Al"] units=["eV/angstrom^2"]
      ```

    python:

      ```
      from kim_python_utils.query import get_surface_energy_ideal_cubic
      get_surface_energy_ideal_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], [1,0,0], ["eV/angstrom^2"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV/angstrom^2"]'       \
           https://query.openkim.org/api/get_surface_energy_ideal_cubic
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    miller : array of three integers
        The miller indices of the surface.  Currently allowed values are [1,0,0],
        [1,1,0], [1,1,1], [1,2,1].

    units : array containing one double-quoted string
        A physical unit of energy per unit area supported by [GNU units](https://www.gnu.org/software/units/)
        in which the relaxed intrinsic stacking fault energy will be returned,
        e.g. "eV/angstrom^2".

    method : array containing one double-quoted string, optional
        The Test Driver used to compute the ideal surface energy for a given lattice
        constant.  Currently allowed values are:

      |-----------------------------------+----------------------------------------------------------|
      | Allowed values                    | Description                                              |
      |-----------------------------------|----------------------------------------------------------|
      | "TD_955413365818"                 | Corresponds to the lineage SurfaceEnergyCubicCrystalBrokenBondFit__TD_955413365818. (default) |
      |-----------------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [ideal_surface_energy] : array containing one float
        The ideal surface energy in the requested units.

    """
    method_synonyms = {}

    allowed_values = {
        "method": [["TD_955413365818"]],
        "miller": [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 2, 1]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "miller": miller,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("miller", miller, int)

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "surface-energy-ideal-cubic-crystal"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # TODO: Make this a function ('match_on_array'?) since this is easily overlooked and
    # won't easily be debugged
    query["query"]["miller-indices.source-value"] = {}
    query["query"]["miller-indices.source-value"]["$eq"] = miller

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["ideal-surface-energy"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_surface_energy_ideal_cubic")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        ideal_surface_energy = helpers.extract_key_from_result(
            results_from_query[0], "ideal-surface-energy", units
        )
        return [ideal_surface_energy]


def get_surface_energy_relaxed_cubic(
    db,
    model,
    crystal,
    species,
    miller,
    units,
    temperature=[0.0],
    temperature_units=["K"],
    temperature_tol=[0.1],
    pressure=[0.0],
    pressure_units=["MPa"],
    pressure_tol=[0.1],
    method=["fire"],
):
    r"""Retrieve free energy of a cubic relaxed surface energy of a
    high-symmetry surface in a cubic crystal comprised of one or more species
    at a given temperature and hydrostatic pressure.  This corresponds to the
    'relaxed' surface energy found by performing an energy minimization.  At
    zero temperature, this corresponds to the potential energy rather than the
    free energy.

    KIM Property Definition: [surface-energy-cubic-crystal-npt](https://openkim.org/properties/show/2014-05-21/staff@noreply.openkim.org/surface-energy-cubic-crystal-npt)

    Usage Examples
    --------------
    LAMMPS:

      ```
      kim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal
      kim_query Erelaxed get_surface_energy_relaxed_cubic crystal=["fcc"] miller=[1,0,0] species=["Al"] units=["eV/angstrom^2"]
      ```

    python:

      ```
      from kim_python_utils.query import get_surface_energy_relaxed_cubic
      get_surface_energy_relaxed_cubic(["MO_123629422045_005"], ["fcc"], ["Al"], [1,0,0], ["eV/angstrom^2"])
      ```

    curl:

      ```
      curl --data-urlencode 'model=["MO_123629422045_005"]' \
           --data-urlencode 'species=["Al"]'                \
           --data-urlencode 'units=["eV/angstrom^2"]'       \
           https://query.openkim.org/api/get_surface_relaxed_ideal_cubic
      ```

    Parameters
    ----------
    model : array containing one double-quoted string
        The KIM ID of the model used to compute the result

    crystal : array containing one double-quoted string
        The short name of the cubic crystal.  Currently allowed values are
        "bcc", "diamond", "fcc", and "sc".

    species : array of double-quoted strings
        The standard chemical symbol(s) of the atomic species comprising the
        crystal, e.g. "Al".

    miller : array of three integers
        The miller indices of the surface.  Currently allowed values are [1,0,0],
        [1,1,0], [1,1,1], [1,2,1].

    units : array containing one double-quoted string
        A physical unit of energy per unit area supported by [GNU units](https://www.gnu.org/software/units/)
        in which the relaxed intrinsic stacking fault energy will be returned,
        e.g. "eV/angstrom^2".

    temperature : array containing one float, optional
        The temperature at which the surface energy is computed.  This value
        should be given in the units specified by the 'temperature_units'
        argument.  (Default: 0.0)

    temperature_units : array containing one double-quoted string, optional
        A physical unit of temperature supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'temperature' argument is given.  (Default: K)

    temperature_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        temperature specified in the given temperature units.  For example, if
        temperature_tol=0.1, temperature=293.15, temperature_units="K", then
        results retrieved by the query must be computed at a temperature of
        293.15 +/- 0.1 K.  If multiple matching results are found, an error is
        returned.  (Default: 0.1)

    pressure : array containing one float, optional
        The pressure at which the surface energy is computed.  This value
        should be given in the units specified by the 'pressure_units'
        argument.  (Default: 0.0)

    pressure_units : array containing one double-quoted string, optional
        A physical unit of pressure supported by [GNU units](https://www.gnu.org/software/units/)
        in which the 'pressure' argument is given.  (Default: MPa)

    pressure_tol : array containing one float, optional
        Indicates a tolerance within which the query results must match the
        pressure specified in the given pressure units.  For example, if
        pressure_tol=0.1, pressure=0.101325, pressure_units="MPa", then results
        retrieved by the query must be computed at a pressure of 0.101325 +/-
        0.1 MPa.  If multiple matching results are found, an error is returned.
        (Default: 0.1)

    method : array containing one double-quoted string, optional
        The algorithm used to minimize the surface energy with respect to the
        atomic positions.  Currently allowed values are:

      |-----------------------------+----------------------------------------------------------|
      | Allowed values              | Description                                              |
      |-----------------------------|----------------------------------------------------------|
      | "TD_955413365818" \| "fire" | Minimization performed using the FIRE damped dynamics method [Bitzek, Koskinen, Gahler, Moseler, Gumbsch, Phys Rev Lett, 97, 170201 (2006)]. (default) |
      |-----------------------------+----------------------------------------------------------|
      {:class="table table-bordered"}
      {:style="width:70%; margin-left:20px;"}
      {:.table-striped}

    Returns
    -------
    [relaxed_surface_energy] : array containing one float
        The relaxed surface energy in the requested units.

    """
    method_synonyms = {"fire": "TD_955413365818"}

    allowed_values = {
        "method": [["TD_955413365818"]],
        "miller": [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 2, 1]],
        "crystal": [["bcc"], ["diamond"], ["fcc"], ["sc"]],
    }

    inputs = {
        "model": model,
        "crystal": crystal,
        "species": species,
        "units": units,
        "miller": miller,
        "temperature_units": temperature_units,
        "temperature_tol": temperature_tol,
        "pressure": pressure,
        "pressure_units": pressure_units,
        "pressure_tol": pressure_tol,
        "method": method,
    }

    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    helpers.check_input_args_are_lists(inputs)

    # Check for uniformity of data types in lists that can have multiple elements
    helpers.check_types_in_input_arg("species", species, str)
    helpers.check_types_in_input_arg("miller", miller, int)
    helpers.check_types_in_input_arg("temperature", temperature, (float, int))
    helpers.check_types_in_input_arg("temperature_tol", temperature_tol, (float, int))
    helpers.check_types_in_input_arg("pressure", pressure, (float, int))
    helpers.check_types_in_input_arg("pressure_tol", pressure_tol, (float, int))

    # Check if synonym was given for method and, if so, map it to a TD shortcode
    method = helpers.process_method(method_synonyms, method)
    inputs["method"] = method

    # Enforce any restrictions on allowed argument values
    helpers.check_args_allowed_values(allowed_values, inputs)

    # Pull scalar values out of lists
    model = model[0]
    crystal = crystal[0]
    units = units[0]
    temperature = temperature[0]
    temperature_units = temperature_units[0]
    temperature_tol = temperature_tol[0]
    pressure = pressure[0]
    pressure_units = pressure_units[0]
    pressure_tol = pressure_tol[0]
    method = method[0]

    # Start with basic test result dict as query
    query = helpers.initialize_test_result_query()

    # Define the property short name we're looking for
    prop = "surface-energy-cubic-crystal-npt"
    query["query"]["property-id"] = {}
    query["query"]["property-id"]["$regex"] = (
        "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
    )

    # Also require that the short-name array contain the specified crystal
    query["query"]["short-name.source-value"] = crystal

    # TODO: Make this a function ('match_on_array'?) since this is easily overlooked and
    # won't easily be debugged
    query["query"]["miller-indices.source-value"] = {}
    query["query"]["miller-indices.source-value"]["$eq"] = miller

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"]["surface-energy"] = 1
    query["fields"]["temperature"] = 1
    query["fields"]["cauchy-stress"] = 1

    # Add filters to query based on the method selected.  This will ensure that all of
    # the results we get back will be for the indicated Test Driver (or its lineage, if
    # no version was specified).  However, note that there may still be multiple
    # versions of a given Test that use the same driver, so we still need to sort on
    # that in any case -- this is done further below.
    helpers.modify_query_for_item(query, "runner.driver", method)
    helpers.modify_query_for_item(query, "subject", model)

    helpers.modify_query_for_species(query, species)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_surface_energy_relaxed_cubic")

    if len(results_from_query) == 0:
        return []
    else:
        # Only pull out the results for the latest test driver version, test version, model
        # version, and timestamp.  Discard errors.
        results_from_query = helpers.filter_on_item_versions_and_timestamp(
            results_from_query
        )

        if len(results_from_query) == 0:
            return []

        final_TestResults = helpers.filter_on_temperature_and_pressure(
            results_from_query,
            temperature,
            temperature_units,
            temperature_tol,
            pressure,
            pressure_units,
            pressure_tol,
        )

        if len(final_TestResults) == 0:
            return []
        else:
            relaxed_surface_energy = helpers.extract_key_from_result(
                final_TestResults[0], "surface-energy", units
            )
            return [relaxed_surface_energy]


def get_test_result(db, test, model, prop, keys, units):
    """
    This function provides a simplified way of querying the KIM mongo database for Test Results.
    Although only a single property may be queried on at a time with this function, multiple keys
    within an individual Property Instance can be returned.  The list of desired keys is specified
    as a square-bracketed, comma-separated list of strings enclosed by double quotes. The user must
    also provide a corresponding list of strings specifying the units in which they would like the
    keys returned.  Each string must correspond to a set of units recognized by the GNU `units`
    command.  Keys which are intrinsically unitless, i.e. those which have 'has-units = False' in
    their Property Definition, must have the value 'null' (without quotes) specified in the units
    key of this function.  The special string "SI" (case-insensitive) may also be used if standard
    SI units are desired for a given key.  The return type of this function is always a
    square-bracketed, comma-separated list (with a space following each comma).  If no valid results
    are found, an empty list is returned.
    """
    # Check that all input args are lists, and that each list contains only a single data
    # type.  We won't bother checking that test, model, etc only contain 1 element
    inputs = {
        "test": test,
        "model": model,
        "prop": prop,
        "keys": keys,
        "units": units,
    }
    helpers.check_input_args_are_lists(inputs)
    helpers.check_types_in_input_arg("keys", keys, str)
    helpers.check_types_in_input_arg("units", units, (str, type(None)))
    helpers.check_for_invalid_null(units)

    if len(units) != len(keys):
        raise Exception(
            "Input argument 'units' to function get_test_result() must be "
            "equal in length to the 'keys' input argument"
        )

    # Pull scalar values out of lists
    test = test[0]
    model = model[0]
    prop = prop[0]

    # Start with basic test result dict as query. Don't set the 'sort' parameter of the
    # query since we need to do our own sorting involving the property ID.
    query = helpers.initialize_test_result_query()

    # The "fields" specify what is returned by the query.  This will include the keys specified
    # by the user, as well as some fields which are used by this function to perform sorting
    query["fields"].update(dict(zip(keys, [1] * len(keys))))

    # Define regular expressions for matching test, model, and property types inputted
    RE_PROPERTY_ID = (
        r"^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property\/[a-z-]+$"
    )
    RE_PROPERTY_SHORT_NAME = r"^[a-z-]+$"

    # Determine whether a full property-id with a contributor and date was given, or only the
    # property short name.  If the full property-id was given, query on it exactly.  If not, do a
    # regex on it
    if re.match(RE_PROPERTY_ID, prop) is not None:
        query["query"]["property-id"] = prop
    elif re.match(RE_PROPERTY_SHORT_NAME, prop) is not None:
        query["query"]["property-id"] = {}
        query["query"]["property-id"]["$regex"] = (
            "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
        )
    else:
        raise ValueError(
            "Invalid property name was passed to function get_test_result()"
        )

    # If either item does not have a version, these functions will add 'history': 1 to the query
    helpers.modify_query_for_item(query, "runner", test)
    helpers.modify_query_for_item(query, "subject", model)

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_test_result")

    if len(results_from_query) == 0:
        return []

    # If we searched with 'history': 1, we may have ended up collecting results from multiple
    # runs. This function picks out the single most up-to-date run from all results.
    # It also ensures only Test Results are included (not errors)
    # This is a redundant safety mechanism, as the query already should not have returned
    # any errors (errors cannot have 'property-id' and property keys)
    final_TestResult = helpers.filter_on_item_versions_and_timestamp(results_from_query)

    # Just in case the removal of errors reduced our list to zero
    if len(final_TestResult)==0:
        return []

    final_output = []
    for result in final_TestResult:
        inner_output=[]
        for ind, key in enumerate(keys):
            if (key not in result) and (
                key + ".source-value" not in result
            ):
                # Because the KDP may be using in-development properties, here the KDP
                # differs from the production pipeline in that the KDP does not do
                # any checking against property definitions, just returns None
                # for missing keys.
                inner_output.append(None)
            else:
                key_value_in_desired_units = helpers.extract_key_from_result(
                    result, key, units[ind]
                )
                inner_output.append(key_value_in_desired_units)
        final_output.append(inner_output)    

    return final_output


def get_reference_data(db, ref_data, species, prop, keys, units):
    """
    This function provides a simplified way of querying the KIM mongo database for Reference Data.
    Although only a single property may be queried on at a time with this function, multiple keys
    within an individual Property Instance can be returned.  The list of desired keys is specified
    as a square-bracketed, comma-separated list of strings enclosed by double quotes. The user must
    also provide a corresponding list of strings specifying the units in which they would like the
    keys returned.  Each string must correspond to a set of units recognized by the GNU `units`
    command.  Keys which are intrinsically unitless, i.e. those which have 'has-units = False' in
    their Property Definition, must have the value 'null' (without quotes) specified in the units
    key of this function.  The special string "SI" may also be used if standard SI units are desired
    for a given key.  The return type of this function is always a {}-bracketed python-style
    dictionary.  If no valid results are found, an empty array is returned.
    IMPORTANT NOTE: Unlike get_test_result, this function does not require that a specific KIM ID
    (with or without a version suffix) be supplied.  As mentioned above, a python-style dictionary
    is always returned as output.  However, the number of entries in this dictionary may vary.  If
    the query finds one or more Property Instances corresponding to only a single Reference Data
    family (that is, potentially for multiple versions but the same 12-digit identification code), a
    dictionary with a single key-value pair will be returned which corresponds to the highest
    version of the Reference Data item if applicable.  The key itself will be a string containing
    the short-id of the Reference Data item, which is of the form RD_DDDDDDDDDDDD_VVV; the value
    associated with the key is a python-style list (square-bracketed, comma-separated) containing
    the values requested through the 'keys' argument.  In the event that Property Instances
    corresponding to multiple Reference Data families are found, the dictionary returned will
    feature multiple key-value pairs, and the number of key-value pairs will be equal to the number
    of distinct Reference Data families found by the query, i.e. the number of distinct 12-digit
    identification Reference Data codes found in the results.  Specifically, each key-value pair
    will correspond to the highest version of one of the distinct Reference Data families.  The key
    itself will be a string containing the short-id of the Reference Data item, while the value will
    be a square-bracketed list containing the values requested through the 'keys' argument to this
    function.  As a python-style dictionary, the order of the key-value pairs in this dictionary is
    undefined, so the string returned by this function has no specific ordering of the different
    Reference Data instances.
    """
    # Initialize dictionary that defines mongodb query. Like Test Results, all Reference Data is
    # under the 'data' database, but has meta.type = "rd"
    query = {}
    query["query"] = {}
    query["fields"] = {}
    query["database"] = "data"
    query["query"]["meta.type"] = "rd"
    query["flat"] = 1
    ref_data_provided = True
    prop_has_ver = False

    # Define regular expressions for matching test, model, and property types inputted
    RE_SHORT_ID = r"^[A-Z]{2}_[0-9]{12}_[0-9]{3}$"
    RE_SHORTCODE = r"^[A-Z]{2}_[0-9]{12}$"
    RE_PROPERTY_ID = (
        r"^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property\/[a-z-]+$"
    )
    RE_PROPERTY_ID_GROUPED = (
        r"^tag:([^A-Z+]+@[^A-Z+]+),([0-9]{4}-[0-9]{2}-[0-9]{2}):property\/([a-z-]+)$"
    )
    RE_PROPERTY_SHORT_NAME = r"^[a-z-]+$"

    # Check to ensure required keyword values were given and of the correct type
    if ref_data is None:
        # We don't require a specific KIM ID of a Reference Data item be given.  If a single RD
        # family (the different versions of an RD item) is found, we'll return a list.  If multiple
        # RD families are found, we'll return a dictionary containing the results corresponding to
        # the highest version of each.
        ref_data_provided = False
    elif not isinstance(ref_data, str):
        raise Exception(
            "If specified, input argument 'ref_data' to function "
            "get_reference_data() must be a string"
        )
    else:
        # Determine if Reference Data ID given is one of:
        # (1) A valid short ID
        # (2) A short ID with no version suffix
        if re.match(RE_SHORT_ID, ref_data) is not None:
            query["query"]["meta.short-id"] = ref_data
            query["history"] = 1
        elif re.match(RE_SHORTCODE, ref_data) is not None:
            query["query"]["meta.short-id"] = {}
            query["query"]["meta.short-id"]["$regex"] = "^" + ref_data + "_[0-9]{3}$"
        else:
            raise Exception(
                "Invalid 'ref_data' argument was passed to function get_reference_data()"
            )

    if species is None:
        raise Exception(
            "Input argument 'species' was not specified in call to function get_reference_data()"
        )
    elif type(species) is not list:
        raise Exception(
            "Input argument 'species' to function get_reference_data() must be a bracketed list"
        )
    else:
        for ind, element in enumerate(species):
            if not isinstance(element, str):
                raise Exception(
                    "Each member of the 'species' list passed as argument to function "
                    "get_reference_data() must be a string."
                    "    Offending item value: "
                    + str(element)
                    + "    Type of offending item: "
                    + str(type(element))
                    + "    Zero-based index of offending item: "
                    + str(ind)
                )

        helpers.modify_query_for_species(query, species)

    if prop is None:
        raise Exception(
            "Input argument 'prop' was not specified in call to function get_reference_data()"
        )
    elif not isinstance(prop, str):
        raise Exception(
            "Input argument 'prop' to function get_reference_data() must be a string"
        )

    # Determine whether a full property-id with a contributor and date was given, or only the
    # property short name.  If the full property-id was given, query on it exactly.  If not, do a
    # regex on it and sort the results from the most recent property-id date to the oldest.  Note
    # that sorting on Reference Data version takes priority over the sorting on property-id.
    if re.match(RE_PROPERTY_ID, prop) is not None:
        query["query"]["property-id"] = prop
        prop_has_ver = True
    elif re.match(RE_PROPERTY_SHORT_NAME, prop) is not None:
        query["query"]["property-id"] = {}
        query["query"]["property-id"]["$regex"] = (
            "^tag:[^A-Z+]+@[^A-Z+]+,[0-9]{4}-[0-9]{2}-[0-9]{2}:property/" + prop + "$"
        )
    else:
        raise Exception(
            "Invalid property name was passed to function get_reference_data()"
        )

    if keys is None:
        raise Exception(
            "Input argument 'keys' was not specified in call to function get_reference_data()"
        )
    elif type(keys) is not list:
        raise Exception(
            "Input argument 'keys' to function get_reference_data() must be a bracketed list"
        )
    else:
        for ind, element in enumerate(keys):
            if not isinstance(element, str):
                raise Exception(
                    "Each member of the 'keys' list passed as argument to function "
                    "get_reference_data() must be a string."
                    "    Offending item value: "
                    + str(element)
                    + "    Type of offending item: "
                    + str(type(element))
                    + "    Zero-based index of offending item: "
                    + str(ind)
                )

        # The "fields" specify what is returned by the query.  This will include the keys specified
        # by the user, as well as some fields which are used by this function to perform sorting
        query["fields"] = dict(zip(keys, [1] * len(keys)))
        query["fields"]["property-id"] = 1
        query["fields"]["meta.short-id"] = 1

    if units is None:
        raise Exception(
            "Input argument 'units' was not specified in call to function get_reference_data()"
        )
    else:
        if type(units) is not list:
            raise Exception(
                "Input argument 'units' to function get_reference_data() must be a "
                "bracketed, comma-separated list"
            )
        else:
            if len(units) != len(keys):
                raise Exception(
                    "Input argument 'units' to function get_reference_data() must be "
                    "equal in length to the 'keys' input argument"
                )
            for ind, unitsentry in enumerate(units):
                if unitsentry is not None and not isinstance(unitsentry, str):
                    raise Exception(
                        "Each member of the 'units' list passed as argument to "
                        "function get_reference_data() must be either a string or null."
                        "    Offending item value: "
                        + str(unitsentry)
                        + "    Type of offending item: "
                        + str(type(unitsentry))
                        + "    Zero-based index of offending item: "
                        + str(ind)
                    )

    # Perform the actual query
    for key in query:
        query[key] = dumps(query[key])
    results_from_query = api_v0(db, query, origin="get_reference_data")

    def sort_on_property_date(results_from_query):
        return sorted(
            results_from_query,
            key=lambda k: re.search(RE_PROPERTY_ID_GROUPED, k["property-id"]).groups(1),
            reverse=True,
        )

    # Always make this a list, even if it will only contain one element.  This is simply done for
    # consistency and simplicity
    final_RefData = []
    if len(results_from_query) == 0:
        return []
    else:
        # Determine necessary sorting before taking the final results
        if ref_data_provided:
            if not prop_has_ver:
                # sort on date string of prop
                final_RefData.append(sort_on_property_date(results_from_query)[0])
            else:
                # No sorting necessary, but make sure to only take one result since there could be
                # duplicates lurking in the database for old versions
                final_RefData.append(results_from_query[0])
        else:
            if len(results_from_query) == 1:
                final_RefData.append(results_from_query)
            elif len(results_from_query) > 1:
                if not prop_has_ver:
                    # With no ref_data and no property version, we could have multiple Reference
                    # Data families (i.e. 12-digit version identifiers, but different 3-digit
                    # version extensions) in the results.  Within each family, only the newest
                    # version of RD should be returned since 'history' is not turned on in this
                    # case.  However, there could still be multiple versions of the property
                    # reported for each of these Reference Data instances.

                    # Identify unique Reference Data families in query results. Each related
                    # instance will be the highest version within that family.
                    unique_RD_families = set(
                        [d["meta.short-id"] for d in results_from_query]
                    )
                    for RD_family in unique_RD_families:
                        # Take the set of all instances from this Reference Data family
                        tmp = [
                            propinstance
                            for propinstance in results_from_query
                            if propinstance["meta.short-id"] == RD_family
                        ]
                        # Take the most recent property version
                        final_RefData.append(sort_on_property_date(tmp)[0])
                else:
                    # As directly above, we should only have the latest version from each RD family,
                    # but now we also know that we only have a specific property version in all of
                    # our results.  Since we're not just sorting on property date and taking the
                    # first result for each RD family, we now have to worry about including
                    # duplicate results in what we return (if we were just doing
                    # final_RefData.append(results_from_query)). Instead, make a temporary
                    # dictionary so that you only pull out one copy of each dictionary that has a
                    # given RD ID for it.
                    tmp = {x["meta.short-id"]: x for x in results_from_query}.values()
                    final_RefData.append(tmp)

    final_output = {}
    for propinstance in final_RefData:
        final_output[propinstance["meta.short-id"]] = []
        for ind, key in enumerate(keys):
            # First, check to make sure the key is actually in the property definition
            if (key not in propinstance) and (
                key + ".source-value" not in propinstance
            ):
                raise Exception(
                    "Key '"
                    + key
                    + "' specified as input to function get_reference_data() "
                    "is not a valid part of the property definition specified or other "
                    "metadata associated with a Reference Data instance"
                )
            if units[ind] is None:
                try:
                    final_output[propinstance["meta.short-id"]].append(
                        propinstance[key]
                    )
                except:
                    # If we were unable to find the key as-is in propinstance, one of the following
                    # is true:
                    # 1.) Is an invalid key that doesn't exist in the property definition
                    # 2.) It has 'si-value' and 'si-units' attached to it, e.g. non-dimensional
                    #     atomic coordinates
                    # 3.) It has 'si-value', 'si-units', 'source-value', and 'source-units' attached
                    #     to it
                    #
                    # If it has si-value attached to it, tell the user they need to give units for
                    # this key
                    if key + ".si-value" in propinstance:
                        raise Exception(
                            "Units were specified as None for key '" + key + "' in "
                            "function get_reference_data(), but units must be associated with "
                            "it according to the property definition specified."
                        )
                    else:
                        # If it does not have si-value attached to it, but does have source-unit
                        # associated with it, add it to the final results list
                        if key + ".source-value" in propinstance:
                            final_output[propinstance["meta.short-id"]].append(
                                propinstance[key + ".source-value"]
                            )
                        else:
                            raise Exception(
                                "UNKNOWN ERROR code 002 from function get_reference_data()"
                            )
            else:
                # Check if the user tried to use "None" or "none" or "Null" or "null" inside quotes.
                # This wouldn't be caught by the JSON decoding done by the API handler
                if units[ind] in ["None", "none", "Null", "null"]:
                    raise Exception(
                        "In order to specify no units for a property key in function "
                        "get_reference_data(), use the JSON keyword null without "
                        "quotes around it"
                    )
                try:
                    this_val = propinstance[key + ".si-value"]
                except:
                    raise Exception(
                        "Units were specified for key '" + key + "' in function "
                        "get_reference_data(), but it has no associated units in the property "
                        "definition specified."
                    )
                this_units = propinstance[key + ".si-unit"]
                if type(this_val) is list:
                    if units[ind].upper() == "SI":
                        converted_val = (
                            this_val  # The result we have is already in SI units
                        )
                    else:
                        try:
                            converted_val = convert_list(
                                x=this_val,
                                from_unit=this_units,
                                to_unit=units[ind],
                                dofit=False,
                            )[0]
                        except:
                            raise Exception(
                                "Unable to convert key '"
                                + key
                                + "' to units of "
                                + units[ind]
                                + " in function get_reference_data()"
                            )
                else:
                    if units[ind].upper() == "SI":
                        converted_val = (
                            this_val  # The result we have is already in SI units
                        )
                    else:
                        try:
                            converted_val = convert_units(
                                from_value=this_val,
                                from_unit=this_units,
                                wanted_unit=units[ind],
                                suppress_unit=True,
                            )
                        except:
                            raise Exception(
                                "Unable to convert key '"
                                + key
                                + "' to units of "
                                + units[ind]
                                + " in function get_reference_data()"
                            )
                final_output[propinstance["meta.short-id"]].append(converted_val)

    return final_output
